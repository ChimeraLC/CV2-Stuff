import cv2
import numpy as np

def Resize(frame, approx):
	flattened = approx.ravel()
	x, y = frame.shape
	# Finding counterclockwise orientation
	grid = [[flattened[0], flattened[1]], 
		[flattened[0], flattened[1]],
		[flattened[0], flattened[1]],
		[flattened[0], flattened[1]]]
	# Top left value
	for i in range(4):
		if (flattened[2*i] + flattened[2*i+1] < grid[0][0] + grid[0][1]):
			grid[0][0] = flattened[2*i]
			grid[0][1] = flattened[2*i+1]
	# Bottom right value
	for i in range(4):
		if (flattened[2*i] + flattened[2*i+1] > grid[2][0] + grid[2][1]):
			grid[2][0] = flattened[2*i]
			grid[2][1] = flattened[2*i+1]

	# Bottom Left value
	for i in range(4):
		if (flattened[2*i] - flattened[2*i+1] < grid[1][0] - grid[1][1]):
			grid[1][0] = flattened[2*i]
			grid[1][1] = flattened[2*i+1]

			
	# Top right value
	for i in range(4):
		if (flattened[2*i] - flattened[2*i+1] > grid[3][0] - grid[3][1]):
			grid[3][0] = flattened[2*i]
			grid[3][1] = flattened[2*i+1]
	
	warpGrid = np.array([[10, 10], [10, y-10], [x-10, y-10], [x-10, 10]], dtype="float32")
	grid = np.array(grid, dtype="float32")

	warpMethod = cv2.getPerspectiveTransform(grid, warpGrid)
	warped = cv2.warpPerspective(frame, warpMethod, (x+10, y+10))
	return warped
	
# Initialize the webcam
cap = cv2.VideoCapture(0)
# Attempts to find the larger tictactoe grid within the image
#def find_grid(frame):
	
found = False
while True:
	# Read each frame from the webcam
	_, frame = cap.read()

	x, y, c = frame.shape

	total_area = x * y

	# Flip the frame vertically
	frame = cv2.flip(frame, 1)
	blur = cv2.blur(frame, (3, 3))
	frame2 = cv2.cvtColor(blur, cv2.COLOR_BGR2GRAY)
	
	thresh = cv2.adaptiveThreshold(
		   frame2, 255, cv2.ADAPTIVE_THRESH_MEAN_C, cv2.THRESH_BINARY, 51, 5
	)



	contours, _ = cv2.findContours(thresh, cv2.RETR_TREE, cv2.CHAIN_APPROX_SIMPLE)
	maxArea = 0
	#cv2.drawContours(frame2, contours, -1, (0,255,0), 3)
	for c in contours:
        # Approximate the contour
		peri = cv2.arcLength(c, True)
		approx = cv2.approxPolyDP(c, 0.01 * peri, True)

		area = cv2.contourArea(c)
        # Check for contours that are quadrilateral and also not too small
		if area > maxArea and len(approx) == 4:
			#cv2.drawContours(frame, [approx], 0, (0, 255, 0), 3)

			warped = Resize(thresh, approx)
			maxArea = area

	# fixing broken lines
	kernel = np.ones((5, 5), np.uint8)  # note this is a horizontal kernel
	d_im = cv2.dilate(warped, kernel, iterations=1)
	e_im = cv2.erode(d_im, kernel, iterations=1) 
	warped = e_im
	
	# Thicken lines
	inner_contours, _ = cv2.findContours(warped, cv2.RETR_TREE, cv2.CHAIN_APPROX_SIMPLE)
	for i in inner_contours:
		cv2.drawContours(warped, [i], -1, (0, 0, 0), 10)
	inner_contours, _ = cv2.findContours(warped, cv2.RETR_TREE, cv2.CHAIN_APPROX_SIMPLE)
	# Find contours
	for i in inner_contours:
		area = cv2.contourArea(i)
		peri = cv2.arcLength(i, True)
		approx = cv2.approxPolyDP(i, 0.01 * peri, True)
		cv2.drawContours(warped, [approx], 0, (255, 255, 0), 3)
	
	cv2.imshow("Output3" ,e_im)
	
	
			
	# Show the final output
	cv2.imshow("Output", thresh) 
	if cv2.waitKey(1) == ord('q'):
		break

# release the webcam and destroy all active windows
cap.release()

cv2.destroyAllWindows()

while (True):
	if (found):
		cv2.imshow("Output", saved)
		for i in range(1):
			cv2.imshow("Output"+ str(i), savedSquares[i])
	else:
		break
	if cv2.waitKey(1) == ord('w'):
		break